## 思路

堆中存放的元素就存放链表第一个元素的指针，排序方式按照第一个元素指针指向的元素的大小来排序，比较简单，直接放代码。

初次建堆时间复杂度$O(nlogn),n是所有链表长度$，下面每获取一个元素调整堆的时间复杂度$O(logn)$，总的时间复杂度$O(nlogn)$。

执行用时：36 ms, 在所有 C++ 提交中击败了49.24%的用户

内存消耗：13 MB, 在所有 C++ 提交中击败了63.57%的用户

[priority_queue的简单应用](https://www.cnblogs.com/yalphait/articles/8889221.html)

## 代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    struct cmp{
        bool operator()(ListNode*aa,ListNode*bb){
            return aa->val>bb->val;
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int n=lists.size();
        // vector<ListNode>vs(n);
        priority_queue<ListNode*,vector<ListNode*>,cmp>q;
        for(auto &ele:lists){
            if(ele){
                q.push(ele);
            }
        }
        ListNode*root=NULL,*cur=NULL;
        ListNode*top=NULL;
        while(!q.empty()){
            top=q.top();
            q.pop();

            if(root!=NULL){
                cur->next=top;
                cur=cur->next;
            }
            else{
                root=top;
                cur=top;
            }
            top=top->next;
            if(top){
                q.push(top);
            }
        }
        if(cur!=NULL)
            cur->next=NULL;
        return root;
    }
};
```

