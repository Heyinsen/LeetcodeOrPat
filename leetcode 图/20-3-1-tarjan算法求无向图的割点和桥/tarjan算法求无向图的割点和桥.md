## tarjan算法求无向图的割点与桥
[一篇tarjan算法求割点与桥的完整的解释,写的真的好认真](https://www.cnblogs.com/nullzx/p/7968110.html)
---
* 以下代码来自kuangbin的模板
> 4.5 图的割点、桥和双连通分支的基本概念
[点连通度与边连通度] 在一个无向连通图中，如果有一个顶点集合，删除这个顶点集合，以
及这个集合中所有顶点相关联的边以后，原图变成多个连通块，就称这个点集为割点集合。
一个图的点连通度的定义为，最小割点集合中的顶点数。
类似的，如果有一个边集合，删除这个边集合以后，原图变成多个连通块，就称这个点集为
割边集合。一个图的边连通度的定义为，最小割边集合中的边数。
[双连通图、割点与桥]
如果一个无向连通图的点连通度大于1，则称该图是点双连通的(point biconnected)，简称
双连通或重连通。一个图有割点，当且仅当这个图的点连通度为1，则割点集合的唯一元素
被称为割点(cut point)，又叫关节点(articulation point)。
如果一个无向连通图的边连通度大于1，则称该图是边双连通的(edge biconnected)，简称双
连通或重连通。一个图有桥，当且仅当这个图的边连通度为1，则割边集合的唯一元素被称
为桥(bridge)，又叫关节边(articulation edge)。
可以看出，点双连通与边双连通都可以简称为双连通，它们之间是有着某种联系的，下文中
提到的双连通，均既可指点双连通，又可指边双连通。
[双连通分支]
在图G 的所有子图G’ 中，如果G’ 是双连通的，则称G’ 为双连通子图。如果一个双连
kuangbin 138
ACM Template of kuangbin
通子图G’ 它不是任何一个双连通子图的真子集，则G’ 为极大双连通子图。双连通分支
(biconnected component)，或重连通分支，就是图的极大双连通子图。特殊的，点双连通分
支又叫做块。[求割点与桥]
该算法是R.Tarjan 发明的。对图深度优先搜索，定义DFS(u) 为u 在搜索树（以下简称为
树）中被遍历到的次序号。定义Low(u) 为u 或u 的子树中能通过非父子边追溯到的最早的
节点，即DFS 序号最小的节点。根据定义，则有：
Low(u)=Min DFS(u) DFS(v) (u,v) 为后向边(返祖边) 等价于DFS(v)<DFS(u) 且v 不为u
的父亲节点Low(v) (u,v) 为树枝边(父子边) 一个顶点u 是割点，当且仅当满足(1) 或(2)
(1) u 为树根，且u 有多于一个子树。(2) u 不为树根，且满足存在(u,v) 为树枝边(或称父子
边，即u 为v 在搜索树中的父亲)，使得DFS(u)<=Low(v)。
一条无向边(u,v) 是桥，当且仅当(u,v) 为树枝边，且满足DFS(u)<Low(v)。
[求双连通分支]
下面要分开讨论点双连通分支与边双连通分支的求法。
对于点双连通分支，实际上在求割点的过程中就能顺便把每个点双连通分支求出。建立一个
栈，存储当前双连通分支，在搜索图时，每找到一条树枝边或后向边(非横叉边)，就把这条
边加入栈中。如果遇到某时满足DFS(u)<=Low(v)，说明u 是一个割点，同时把边从栈顶一
个个取出，直到遇到了边(u,v)，取出的这些边与其关联的点，组成一个点双连通分支。割点
可以属于多个点双连通分支，其余点和每条边只属于且属于一个点双连通分支。
对于边双连通分支，求法更为简单。只需在求出所有的桥以后，把桥边删除，原图变成了多
个连通块，则每个连通块就是一个边双连通分支。桥不属于任何一个边双连通分支，其余的
边和每个顶点都属于且只属于一个边双连通分支。
[构造双连通图]
一个有桥的连通图，如何把它通过加边变成边双连通图？方法为首先求出所有的桥，然后删
除这些桥边，剩下的每个连通块都是一个双连通子图。把每个双连通子图收缩为一个顶点，
再把桥边加回来，最后的这个图一定是一棵树，边连通度为1。
统计出树中度为1 的节点的个数，即为叶节点的个数，记为leaf。则至少在树上添加
(leaf+1)/2 条边，就能使树达到边二连通，所以至少添加的边数就是(leaf+1)/2。具体方
法为，首先把两个最近公共祖先最远的两个叶节点之间连接一条边，这样可以把这两个点到
祖先的路径上所有点收缩到一起，因为一个形成的环一定是双连通的。然后再找两个最近公
共祖先最远的两个叶节点，这样一对一对找完，恰好是(leaf+1)/2 次，把所有点收缩到了一
起。
```c++
/*
* 求无向图的割点和桥
* 可以找出割点和桥，求删掉每个点后增加的连通块。
* 需要注意重边的处理，可以先用矩阵存，再转邻接表，或者进行判重
*/
const int MAXN = 10010;
const int MAXM = 100010;
struct Edge {
	int to, next;
	bool cut;//是否为桥的标记
}edge[MAXM];
int head[MAXN], tot;
int Low[MAXN], DFN[MAXN];

int Stack[MAXN];
int Index, top;
bool Instack[MAXN];

bool cut[MAXN];//每个顶点是否为割的标记
int add_block[MAXN];//删除一个点后增加的连通块

int bridge;
void addedge(int u, int v) {
	edge[tot].to = v;
	edge[tot].next = head[u];
	edge[tot].cut = false;
	head[u] = tot++;
}

//当前顶点u,u的父亲节点pre
void Tarjan(int u, int pre) {
	int v;
	Low[u] = DFN[u] = ++Index;
	Stack[top++] = u;
	Instack[u] = true;
	
	//儿子节点
	int son = 0;
	int pre_cnt = 0; //处理重边，如果不需要可以去掉
	for (int i = head[u]; i != −1; i = edge[i].next) {
		v = edge[i].to;
		//v是u的父亲节点并且重边的个数为1,重边的个数++
			//上面说明找到了一条重边, 处理重边
		if (v == pre && pre_cnt == 0) { pre_cnt++; continue; }
		//第一种情况, 下一条边未被DFS过
			//son++
			//递归Tarjan
			//更新low[]数组
				//low[u]=min(low[u],low[v])
				//low[i]代表顶点i不经过父节点可以达到的最早的祖先节点
		if (!DFN[v]) {
			son++;
			Tarjan(v, u);
			if (Low[u] > Low[v])Low[u] = Low[v];
			//桥
			//一条无向边(u,v) 是桥，当且仅当(u,v) 为树枝边，且满足DFS(u) < Low(v)。
			if (Low[v] > DFN[u]) {
				bridge++;
				edge[i].cut = true;
				edge[i ^ 1].cut = true;
			}
			//割点
			//一个顶点u 是割点，当且仅当满足(1) 或(2) (1) u 为树根，且u有多于一个子树。
			//(2) u 不为树根，且满足存在(u,v) 为树枝边(或称父子边，
			//即u 为v 在搜索树中的父亲)，使得DFS(u)<=Low(v)
			
			//u是割点, 当且仅当u不是第一个DFS的节点(根节点)并且其某个子树节点无法通过u遍历到u的祖先节点 
			if (u != pre && Low[v] >= DFN[u]) {//不是树根
				cut[u] = true;
				add_block[u]++;
			}
		}
		//找到祖先节点
		else if (Low[u] > DFN[v])
			Low[u] = DFN[v];
	}
	//树根，分支数大于1, 必然是割点
	if (u == pre && son > 1)cut[u] = true;
	//增加的联通块的个数
	if (u == pre)add_block[u] = son - 1;
	Instack[u] = false;
	top--;
}
```